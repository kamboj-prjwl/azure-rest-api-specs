name: Create Branch from Upstream

on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: 'Name of the branch that exists in upstream (Azure/azure-rest-api-specs)'
        required: true
        type: string
      new_api_version:
        description: 'New API version (e.g., 2024-09-01)'
        required: true
        type: string
      latest_api_version:
        description: 'Latest API version to copy from (e.g., 2024-06-01)'
        required: true
        type: string

jobs:
  create-branch-from-upstream:
    runs-on: ubuntu-latest
    
    steps:
      - name: Configure Git for Long Paths
        run: |
          git config --global core.longpaths true
          git config --global user.name "kamboj-prjwl"
          git config --global user.email "kamboj-prjwl@gmail.com"
          
      - name: Checkout Fork Repository
        uses: actions/checkout@v4
        with:
          # Fetch all history for all branches and tags
          fetch-depth: 0
          # Use the default token for authentication
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Add Upstream Remote
        run: |
          # Add the upstream repository as a remote
          git remote add upstream https://github.com/Azure/azure-rest-api-specs.git
          
          # Verify remotes are configured correctly
          echo "Configured remotes:"
          git remote -v
          
      - name: Fetch Upstream Branches
        run: |
          echo "Fetching all branches from upstream..."
          git fetch upstream --prune
          
          # List all upstream branches for verification
          echo "Available upstream branches:"
          git branch -r | grep upstream
          
      - name: Verify Upstream Branch Exists
        run: |
          # Check if the specified branch exists in upstream
          if git ls-remote --heads upstream | grep -q "refs/heads/${{ inputs.branch_name }}"; then
            echo "‚úÖ Branch '${{ inputs.branch_name }}' exists in upstream"
          else
            echo "‚ùå Branch '${{ inputs.branch_name }}' does not exist in upstream"
            exit 1
          fi
          
      - name: Clean Local Repository State
        run: |
          # Ensure we're on a safe branch (main/master)
          git checkout main 2>/dev/null || git checkout master 2>/dev/null || git checkout -b temp-safe-branch
          
          # Remove any existing local branch with the same name
          if git show-ref --verify --quiet "refs/heads/${{ inputs.branch_name }}"; then
            echo "Removing existing local branch '${{ inputs.branch_name }}'"
            git branch -D "${{ inputs.branch_name }}"
          fi
          
          # Clean any untracked files and directories
          git clean -fdx
          
          # Reset any staged changes
          git reset --hard HEAD
          
          # Remove any existing locks
          rm -f .git/index.lock
          rm -f .git/HEAD.lock
          find .git/refs -name "*.lock" -type f -delete 2>/dev/null || true
          
      - name: Create New Branch from Upstream
        id: create_branch
        run: |
          # Create and checkout new branch from upstream
          echo "Creating new branch '${{ inputs.branch_name }}' from upstream..."
          git checkout -b "${{ inputs.branch_name }}" "upstream/${{ inputs.branch_name }}"
          
          # Verify we're on the correct branch
          current_branch=$(git branch --show-current)
          echo "Current branch: $current_branch"
          
          if [ "$current_branch" = "${{ inputs.branch_name }}" ]; then
            echo "‚úÖ Successfully switched to branch '${{ inputs.branch_name }}'"
            echo "branch_created=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to switch to branch '${{ inputs.branch_name }}'"
            exit 1
          fi
          
      - name: Push Branch to Fork
        run: |
          # Push the new branch to the fork (origin)
          echo "Pushing branch '${{ inputs.branch_name }}' to fork..."
          git push origin "${{ inputs.branch_name }}" --force
          
          echo "‚úÖ Branch successfully pushed to fork"
          
      - name: Validate PowerShell Execution
        if: success() && steps.create_branch.outputs.branch_created == 'true'
        shell: pwsh
        run: |
          # PowerShell validation step
          Write-Host "========================================" -ForegroundColor Green
          Write-Host "PowerShell Execution Validation" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Green
          
          # Get current branch name
          $currentBranch = git branch --show-current
          Write-Host "Current Branch Name: $currentBranch" -ForegroundColor Yellow
          
          # Validate branch name matches input
          if ($currentBranch -eq "${{ inputs.branch_name }}") {
              Write-Host "‚úÖ Branch validation successful!" -ForegroundColor Green
              Write-Host "Branch '${{ inputs.branch_name }}' is active" -ForegroundColor Green
          } else {
              Write-Host "‚ùå Branch validation failed!" -ForegroundColor Red
              exit 1
          }
          
          # Additional PowerShell operations can be added here
          Write-Host "`nBranch Information:" -ForegroundColor Cyan
          git log --oneline -n 5
          
          Write-Host "`nRepository Status:" -ForegroundColor Cyan
          git status
          
      - name: Execute Copy-ApiVersion Script
        if: success() && steps.create_branch.outputs.branch_created == 'true'
        shell: pwsh
        run: |
          Write-Host "Executing Copy-ApiVersion Script" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Blue
          
          # Display the parameters that will be used
          Write-Host "Script Parameters:" -ForegroundColor Yellow
          Write-Host "  - New API Version: ${{ inputs.new_api_version }}" -ForegroundColor White
          Write-Host "  - Latest API Version: ${{ inputs.latest_api_version }}" -ForegroundColor White
          Write-Host "  - Service: network" -ForegroundColor White
          Write-Host "  - Type: resource-manager" -ForegroundColor White
          Write-Host "  - Provider: Microsoft.Network" -ForegroundColor White
          
          # Check if the script exists
          $scriptPath = ".\eng\scripts\Copy-ApiVersion.ps1"
          if (Test-Path $scriptPath) {
              Write-Host "`n‚úÖ Script found at: $scriptPath" -ForegroundColor Green
              
              # Execute the script
              Write-Host "`nExecuting Copy-ApiVersion script..." -ForegroundColor Cyan
              try {
                  & $scriptPath network resource-manager Microsoft.Network "stable/${{ inputs.new_api_version }}" "stable/${{ inputs.latest_api_version }}"
                  Write-Host "`n‚úÖ Copy-ApiVersion script executed successfully!" -ForegroundColor Green
              }
              catch {
                  Write-Host "`n‚ùå Error executing Copy-ApiVersion script:" -ForegroundColor Red
                  Write-Host $_.Exception.Message -ForegroundColor Red
                  throw
              }
          } else {
              Write-Host "`n‚ùå Script not found at: $scriptPath" -ForegroundColor Red
              Write-Host "Available files in eng/scripts directory:" -ForegroundColor Yellow
              if (Test-Path ".\eng\scripts\") {
                  Get-ChildItem ".\eng\scripts\" -Name | ForEach-Object { Write-Host "  - $_" -ForegroundColor White }
              } else {
                  Write-Host "  eng/scripts directory not found" -ForegroundColor Red
              }
              throw "Copy-ApiVersion.ps1 script not found"
          }
          
      - name: Push Changes to Branch
        if: success() && steps.create_branch.outputs.branch_created == 'true'
        run: |
          echo "üì§ Pushing all changes to branch '${{ inputs.branch_name }}'..."
          
          # Push the changes (changes were already committed in PowerShell step)
          git push origin "${{ inputs.branch_name }}" --force
          
          echo "‚úÖ All changes pushed successfully to branch '${{ inputs.branch_name }}'"
          
      - name: Create Pull Request
        if: success() && steps.create_branch.outputs.branch_created == 'true'
        run: |
          echo "üîÄ Creating pull request from '${{ inputs.branch_name }}' to 'main'..."
          
          # Create pull request using GitHub CLI
          gh pr create \
            --title "Copy API version from stable/${{ inputs.latest_api_version }} to stable/${{ inputs.new_api_version }} for Microsoft.Network" \
            --body "## Summary
          
          This PR copies the API version from \`stable/${{ inputs.latest_api_version }}\` to \`stable/${{ inputs.new_api_version }}\` for Microsoft.Network.
          
          ## Changes Made
          - Executed Copy-ApiVersion.ps1 script with the following parameters:
            - Service: network
            - Type: resource-manager  
            - Provider: Microsoft.Network
            - New API Version: stable/${{ inputs.new_api_version }}
            - Source API Version: stable/${{ inputs.latest_api_version }}
          
          ## Workflow Details
          - **Source Branch**: ${{ inputs.branch_name }}
          - **Upstream Repository**: Azure/azure-rest-api-specs
          - **Generated by**: GitHub Actions workflow
          - **Timestamp**: $(date)
          
          ## Next Steps
          Please review the changes and merge when ready." \
            --head "${{ inputs.branch_name }}" \
            --base "main"
          
          echo "‚úÖ Pull request created successfully!"
          
          # Get the PR URL for the summary
          PR_URL=$(gh pr view "${{ inputs.branch_name }}" --json url --jq '.url')
          echo "üîó Pull Request URL: $PR_URL"
          echo "PR_URL=$PR_URL" >> $GITHUB_ENV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Summary Report
        if: always()
        run: |
          echo "## Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Input Branch**: ${{ inputs.branch_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **New API Version**: ${{ inputs.new_api_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Latest API Version**: ${{ inputs.latest_api_version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Upstream Repository**: Azure/azure-rest-api-specs" >> $GITHUB_STEP_SUMMARY
          echo "- **Fork Repository**: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Workflow Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.create_branch.outputs.branch_created }}" = "true" ]; then
            echo "‚úÖ **Branch successfully created and pushed to fork**" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Copy-ApiVersion script executed and changes committed**" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ **Changes pushed to branch**" >> $GITHUB_STEP_SUMMARY
            if [ ! -z "$PR_URL" ]; then
              echo "‚úÖ **Pull request created**: [$PR_URL]($PR_URL)" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ö†Ô∏è **Pull request creation status unknown**" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚ùå **Branch creation failed or not completed**" >> $GITHUB_STEP_SUMMARY
          fi
          
      - name: Cleanup on Success or Failure
        if: always()
        run: |
          echo "Performing cleanup..."
          
          # Remove any git locks if they exist
          rm -f .git/index.lock
          rm -f .git/HEAD.lock
          rm -f .git/refs/heads/*.lock
          find .git -name "*.lock" -type f -delete 2>/dev/null || true
          
          # Clean up any temporary files
          git clean -fdx 2>/dev/null || true
          
          # Reset to a clean state (only if we can)
          git reset --hard HEAD 2>/dev/null || true
          
          echo "‚úÖ Cleanup completed"

  # Separate cleanup job that always runs to ensure locks are removed
  cleanup-locks:
    runs-on: ubuntu-latest
    needs: create-branch-from-upstream
    if: always()
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Remove All Git Locks
        run: |
          echo "Ensuring all git locks are removed..."
          
          # Find and remove all lock files in .git directory
          if [ -d ".git" ]; then
            find .git -type f -name "*.lock" -delete 2>/dev/null || true
            
            # Specifically target common lock locations
            rm -f .git/index.lock 2>/dev/null || true
            rm -f .git/HEAD.lock 2>/dev/null || true
            rm -rf .git/refs/heads/*.lock 2>/dev/null || true
            rm -rf .git/refs/remotes/*/*.lock 2>/dev/null || true
            
            echo "‚úÖ All git locks have been removed"
          else
            echo "‚ö†Ô∏è .git directory not found"
          fi
          
      - name: Verify Lock Removal
        run: |
          echo "Verifying no locks remain..."
          
          lock_count=$(find .git -name "*.lock" 2>/dev/null | wc -l || echo "0")
          
          if [ "$lock_count" -eq 0 ]; then
            echo "‚úÖ Verified: No git locks found"
          else
            echo "‚ö†Ô∏è Warning: $lock_count lock file(s) still found"
            find .git -name "*.lock" 2>/dev/null || true
          fi
          
      - name: Final Status Report
        run: |
          echo "## Cleanup Job Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Previous Job Status**: ${{ needs.create-branch-from-upstream.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cleanup Status**: Completed" >> $GITHUB_STEP_SUMMARY
          echo "- **All git locks removed**: ‚úÖ" >> $GITHUB_STEP_SUMMARY
          echo "- **Cleanup completed at**: $(date)" >> $GITHUB_STEP_SUMMARY
